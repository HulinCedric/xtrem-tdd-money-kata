  # No Exception Authorized
- We start by identifying where we use exceptions
```c#
public class Bank {
    ...
    public Money Convert(Money money, Currency to) =>
    CanConvert(money.Currency, to)
        ? ConvertSafely(money, to)
        : throw new MissingExchangeRateException(money.Currency, to);
    ...
}

public class Portfolio {
    ...

    private static ConversionResult ConvertMoney(Bank bank, Currency currency, Money money)
    {
        try
        {
            return new ConversionResult(bank.Convert(money, currency));
        }
        catch (MissingExchangeRateException exception)
        {
            return new ConversionResult(exception);
        }
    }
    ...
}
```

- We have a few options to remove exceptions
  - Use Hollywood principle -> callback functions `OnSuccess`, `OnFailure`
  - Use a data structure representing computation results : `Success` or `Failure`

- We have already used such a type : `ConversionResult`
  - Let's iterate on it

## Portfolio
- We start, as usual, with a red test at the `Portfolio` level
  - We rename the `Evaluate` method into `EvaluateWithException`

```c#
[Fact(DisplayName = "5 USD + 10 EUR + 4 EUR = 21.8 USD")]
public void Add_ShouldAddMoneyInDollarsAndMultipleAmountInEuros() =>
    PortfolioWith(new Money(5, Currency.USD), new Money(10, Currency.EUR), new Money(4, Currency.EUR))
        .EvaluateWithException(bank, Currency.USD)
        .Should()
        .Be(new Money(21.8, Currency.USD));

[Fact(DisplayName = "Throws a MissingExchangeRatesException in case of missing exchange rates")]
public void Add_ShouldThrowAMissingExchangeRatesException()
{
    PortfolioWith(new Money(1, Currency.EUR), new Money(1, Currency.USD), new Money(1, Currency.KRW))
        .Evaluate(this.bank, Currency.EUR)
        .Failure
        .Should()
        .Be("Missing exchange rate(s): [USD->EUR],[KRW->EUR]");
}
```

- We generate `evaluate` method from the test
  - We need to change `ConversionResult` accessibility as well

```c#
public ConversionResult Evaluate(Bank bank, Currency eur)
{
    throw new NotImplementedException();
}

public class ConversionResult
{
}
```
- Let's implement the `evaluate` by calling the old one first
```c#
public ConversionResult Evaluate(Bank bank, Currency currency)
{
    try {
        return new ConversionResult(
            this.EvaluateWithException(bank, currency)
        );
    } catch (MissingExchangeRatesException exception) {
        return new ConversionResult(exception);
    }
}
```
- We need to adapt the `ConversionResult` to support another `Exception` type
  - Let's this type supports a Generic Failure
```c#
public class ConversionResult<T>
{
    public Money? Money { get; }

    public T? Failure { get; }
    
    public ConversionResult(Money money)
    {
        this.Money = money;
    }

    public ConversionResult(T failure)
    {
        this.Failure = failure;
    }

    public bool IsFailure() => this.Failure is { };

    public bool IsSuccess() => this.Money is { };
}
```
- We need to adapt our `Portfolio` to use the Generic type everywhere
```c#
public class Portfolio
{
    public Money EvaluateWithException(Bank bank, Currency currency)
    {
        List<ConversionResult<MissingExchangeRateException>> results = this.GetConvertedMoneys(bank, currency);
        return ContainsFailure(results)
            ? throw ToException(results)
            : ToMoney(results, currency);
    }

    private static MissingExchangeRatesException ToException(
        IEnumerable<ConversionResult<MissingExchangeRateException>> results) =>
        new(results
            .Where(result => result.IsFailure())
            .Select(result => result.Failure!)
            .ToList());

    private static Money ToMoney(IEnumerable<ConversionResult<MissingExchangeRateException>> results,
        Currency currency) =>
        new(results.Sum(result => result.Money!.Amount), currency);

    private static bool ContainsFailure(IEnumerable<ConversionResult<MissingExchangeRateException>> results) =>
        results.Any(result => result.IsFailure());

    private List<ConversionResult<MissingExchangeRateException>> GetConvertedMoneys(Bank bank, Currency currency) =>
        this.moneys
            .Select(money => ConvertMoney(bank, currency, money))
            .ToList();

    private static ConversionResult<MissingExchangeRateException> ConvertMoney(Bank bank, Currency currency,
        Money money)
    {
        try
        {
            return new ConversionResult<MissingExchangeRateException>(bank.Convert(money, currency));
        }
        catch (MissingExchangeRateException exception)
        {
            return new ConversionResult<MissingExchangeRateException>(exception);
        }
    }

    public ConversionResult<string> Evaluate(Bank bank, Currency currency)
    {
        try
        {
            return new ConversionResult<string>(
                this.EvaluateWithException(bank, currency)
            );
        }
        catch (MissingExchangeRatesException exception)
        {
            return new ConversionResult<string>(exception.Message);
        }
    }
}
```
- Our test is now green
- Let's refactor
    - We implement the new evaluation logic
      - Because we will have to change method signature we choose to duplicate the code

```c#
private static string GetMissingRates(IEnumerable<MissingExchangeRateException> missingRates) => missingRates
    .Select(exception => $"[{exception.Message}]")
    .Aggregate((r1, r2) => $"{r1},{r2}");

public ConversionResult<string> Evaluate(Bank bank, Currency currency)
{
    List<ConversionResult<MissingExchangeRateException>> results = this.GetConvertedMoneys(bank, currency);
    if (ContainsFailure(results))
    {
        return new ConversionResult<string>($"Missing exchange rate(s): {GetMissingRates(results.Where(result => result.IsFailure()).Select(result => result.Failure!))}");
    }

    return new ConversionResult<string>(new Money(results
        .Where(result => result.IsSuccess())
        .Sum(result => result.Money!.Amount), currency));
}
```

- Let's adapt a first test to use new `evaluate` method
  - Code is no longer throwing `Exception`
  - We need to access `money()` from `ConversionResult`

```java
@Test
@DisplayName("5 USD + 10 USD = 15 USD")
void shouldAddMoneyInTheSameCurrency() {
    var portfolio = portfolioWith(
            dollars(5),
            dollars(10)
    );

    assertThat(portfolio.evaluate(bank, USD)
            .money())
            .isEqualTo(dollars(15));
}
```

- We can now remove dead code and duplication
  - Method `evaluateWithException` is no longer used
    - Its related private methods as well : `toMissingExchangeRatesException`, `toMoney`
  - The `MissingExchangeRatesException` can be deleted as well

- We can make some clean up: 
  - Extract inner public class in its own file
  - Extract some methods from the `evaluate` one

```java
public ConversionResult<String> evaluate(Bank bank, Currency toCurrency) {
    var convertedMoneys = convertAllMoneys(bank, toCurrency);

    return containsFailure(convertedMoneys)
            ? new ConversionResult<>(toFailure(convertedMoneys))
            : new ConversionResult<>(sumConvertedMoney(convertedMoneys, toCurrency));
}

private Money sumConvertedMoney(List<ConversionResult<MissingExchangeRateException>> convertedMoneys, Currency toCurrency) {
    return new Money(convertedMoneys.stream()
            .filter(ConversionResult::isSuccess)
            .mapToDouble(c -> c.money().amount())
            .sum(), toCurrency);
}

private String toFailure(List<ConversionResult<MissingExchangeRateException>> convertedMoneys) {
    return convertedMoneys.stream()
            .filter(ConversionResult::isFailure)
            .map(ConversionResult::failure)
            .map(e -> String.format("[%s]", e.getMessage()))
            .collect(Collectors.joining(",", "Missing exchange rate(s): ", ""));
}
```
- We may express success and failure in more visual way
  - Let's refactor it 

```java
public ConversionResult<String> evaluate(Bank bank, Currency toCurrency) {
    var convertedMoneys = convertAllMoneys(bank, toCurrency);

    return containsFailure(convertedMoneys)
            ? ConversionResult.fromFailure(toFailure(convertedMoneys))
            : ConversionResult.fromSuccess(sumConvertedMoney(convertedMoneys, toCurrency));
}

public record ConversionResult<Failure>(Money money, Failure failure) {
    private ConversionResult(Money money) {
        this(money, null);
    }

    private ConversionResult(Failure exception) {
        this(null, exception);
    }

    public static <F> ConversionResult<F> fromFailure(F failure) {
        return new ConversionResult<>(failure);
    }

    public static <F> ConversionResult<F> fromSuccess(Money money) {
        return new ConversionResult<>(money);
    }

    public boolean isFailure() {
        return failure != null;
    }

    public boolean isSuccess() {
        return money != null;
    }
}
```

- We have already removed 1 `Exception` now we need to do the same at the `Bank` level

## Bank
- Let's start with a red test
```java
@Test
@DisplayName("Return a failure result in case of missing exchange rate")
void shouldReturnAFailingResultInCaseOfMissingExchangeRate() {
    assertThat(bank.convert(euros(10), KRW)
            .failure())
            .isEqualTo("EUR->KRW");
}
```

- Let's rename the existing `convert` to `convertWithException` and generate the code from our test

```java
public Money convertWithException(Money money, Currency to) throws MissingExchangeRateException {
    if (!canConvert(money, to)) {
        throw new MissingExchangeRateException(money.currency(), to);
    }
    return convertSafely(money, to);
}

public ConversionResult<String> convert(Money money, Currency to) {
    return null;
}
```

- Make our test green
```java
public Money convertWithException(Money money, Currency to) throws MissingExchangeRateException {
    if (!canConvert(money, to)) {
        throw new MissingExchangeRateException(money.currency(), to);
    }
    return convertSafely(money, to);
}

public ConversionResult<String> convert(Money money, Currency to) {
    try {
        return fromSuccess(convertWithException(money, to));
    } catch (MissingExchangeRateException e) {
        return fromFailure(e.getMessage());
    }
} 
```

- Let's refactor
```java
public ConversionResult<String> convert(Money money, Currency to) {
    return canConvert(money, to)
            ? fromSuccess(convertSafely(money, to))
            : fromFailure(String.format("%s->%s", money.currency(), to));
} 
```
- Adapt our callers to use the new `convert`: `Portfolio` and `BankTest`
  - Really easy in the tests
- We have some work to refactor the `Porftolio`
  - We start by changing the `convertAllMoneys` method
```java
private List<ConversionResult<String>> convertAllMoneys(Bank bank, Currency toCurrency) {
    return moneys.stream()
            .map(money -> bank.convert(money, toCurrency))
            .toList();
}

// Delete it -> not needed anymore
private ConversionResult<MissingExchangeRateException> convertMoney(Bank bank, Money money, Currency toCurrency) {
    try {
        return fromSuccess(bank.convertWithException(money, toCurrency));
    } catch (MissingExchangeRateException missingExchangeRateException) {
        return fromFailure(missingExchangeRateException);
    }
}
```
- We adapt methods in `Portfolio` to only use `ConversionResult<String>`
```java
public ConversionResult<String> evaluate(Bank bank, Currency toCurrency) {
    var convertedMoneys = convertAllMoneys(bank, toCurrency);

    return containsFailure(convertedMoneys)
            ? fromFailure(toFailure(convertedMoneys))
            : fromSuccess(sumConvertedMoney(convertedMoneys, toCurrency));
}

private Money sumConvertedMoney(List<ConversionResult<String>> convertedMoneys, Currency toCurrency) {
    return new Money(convertedMoneys.stream()
            .filter(ConversionResult::isSuccess)
            .mapToDouble(c -> c.money().amount())
            .sum(), toCurrency);
}

private String toFailure(List<ConversionResult<String>> convertedMoneys) {
    return convertedMoneys.stream()
            .filter(ConversionResult::isFailure)
            .map(ConversionResult::failure)
            .map(e -> String.format("[%s]", e))
            .collect(Collectors.joining(",", "Missing exchange rate(s): ", ""));
}

private boolean containsFailure(List<ConversionResult<String>> convertedMoneys) {
    return convertedMoneys
            .stream()
            .anyMatch(ConversionResult::isFailure);
}

private List<ConversionResult<String>> convertAllMoneys(Bank bank, Currency toCurrency) {
    return moneys.stream()
            .map(money -> bank.convert(money, toCurrency))
            .toList();
} 
```
- We can now remove the `convertWithException` method in `Bank` and `MissingExchangeRateException`

## Reflect
![No exception](../../docs/img/no-exception.png)

`What can be still improved?`
  - The way we use the `ConversionResult` is not safe for example...
  - Maybe there is an alternative to use safer data structure
  - You can discover more about the `Monad` concepts and how to apply them in java with [vavr](https://www.vavr.io/)