# No For Loops
- We have only 1 method concerned by this constraint

```c#
public Money Evaluate(Bank bank, Currency currency)
{
    double convertedResult = 0;
    var missingExchangeRates = new List<MissingExchangeRateException>();
    foreach (Money money in this.moneys)
    {
        try
        {
            Money convertedMoney = bank.Convert(money, currency);
            convertedResult += convertedMoney.Amount;
        }
        catch (MissingExchangeRateException exception)
        {
            missingExchangeRates.Add(exception);
        }
    }
    
    if (missingExchangeRates.Any()) {
        throw new MissingExchangeRatesException(missingExchangeRates);
    }
    
    // Simply instantiate a new Money from here
    return new Money(convertedResult, currency);
}
```

> We can safely refactor because our code has been designed using TDD -> we have a high coverage as a side effect (safety net for refactoring)

## First step - remove the foreach
We will use the `.ForEach` method from the `List<T>` class. It allows us to reduce the cyclomatic complexity. 

The code is almost the same but there's a significant difference. Instead of **iterating on** every element, we **apply a function to** every element.

We're on the right path but we can't extract this behavior in a method **yet**. There are two external states: `ConvertedResult` and `MissingExchangeRates`.
```c#
public Money Evaluate(Bank bank, Currency currency)
{
    double convertedResult = 0;
    var missingExchangeRates = new List<MissingExchangeRateException>();
    this.moneys.ToList().ForEach(money =>
    {
        try
        {
            Money convertedMoney = bank.Convert(money, currency);
            convertedResult += convertedMoney.Amount;
        }
        catch (MissingExchangeRateException exception)
        {
            missingExchangeRates.Add(exception);
        }
    });
    
    if (missingExchangeRates.Any()) {
        throw new MissingExchangeRatesException(missingExchangeRates);
    }
    
    // Simply instantiate a new Money from here
    return new Money(convertedResult, currency);
}
```

## Second step - remove mutation
- To remove the `mutation` we need to think about how to sum our ConversionResult from the `Bank`
- We start by implementing a new method `ConvertMoney` that returns a `ConversionResult`
  - This type will encapsulate the fact that conversion can success (contains a Money) or fail (throws an exception)
```c#
private static ConversionResult ConvertMoney(Bank bank, Currency currency, Money money)
{
    try
    {
        return new ConversionResult(bank.Convert(money, currency));
    }
    catch (MissingExchangeRateException exception)
    {
        return new ConversionResult(exception);
    }
}

private class ConversionResult
{
    private readonly MissingExchangeRateException? exception;

    private readonly Money? money;

    public ConversionResult(Money money)
    {
        this.money = money;
    }

    public ConversionResult(MissingExchangeRateException exception)
    {
        this.exception = exception;
    }
}
```

- Let's use it in our `Evaluate`
  - We start by converting all the moneys
```c#
private List<ConversionResult> GetConvertedMoneys(Bank bank, Currency currency) =>
    this.moneys
        .Select(money => ConvertMoney(bank, currency, money))
        .ToList();
```
- Then we need to check if we have any conversion errors aka `MissingExchangeRateException`
  - We add a method on `ConversionResult` to make it explicit
```c#
private static MissingExchangeRatesException ToException(IEnumerable<ConversionResult> results) =>
    new(results
        .Where(result => result.HasException())
        .Select(result => result.GetExceptionUnsafe())
        .ToList());
```
- We can now safely return the `Money` result
```c#
private static Money ToMoney(IEnumerable<ConversionResult> results, Currency currency) =>
    new(results.Sum(result => result.GetMoneyUnsafe().Amount), currency);
```

- What can be improved ?
  - Simplify the `evaluate` method by extracting `private` methods with explicit names

```c#
public class Portfolio 
{
     private readonly ICollection<Money> moneys = new List<Money>();

    public void Add(Money money) => this.moneys.Add(money);

    public Money Evaluate(Bank bank, Currency currency)
    {
        List<ConversionResult> results = this.GetConvertedMoneys(bank, currency);
        return ContainsFailure(results)
            ? throw ToException(results)
            : ToMoney(results, currency);
    }

    private static MissingExchangeRatesException ToException(IEnumerable<ConversionResult> results) =>
        new(results
            .Where(result => result.HasException())
            .Select(result => result.GetExceptionUnsafe())
            .ToList());

    private static Money ToMoney(IEnumerable<ConversionResult> results, Currency currency) =>
        new(results.Sum(result => result.GetMoneyUnsafe().Amount), currency);

    private static bool ContainsFailure(IEnumerable<ConversionResult> results) =>
        results.Any(result => result.HasException());

    private List<ConversionResult> GetConvertedMoneys(Bank bank, Currency currency) =>
        this.moneys
            .Select(money => ConvertMoney(bank, currency, money))
            .ToList();

    private static ConversionResult ConvertMoney(Bank bank, Currency currency, Money money)
    {
        try
        {
            return new ConversionResult(bank.Convert(money, currency));
        }
        catch (MissingExchangeRateException exception)
        {
            return new ConversionResult(exception);
        }
    }
}
```

## Reflect
- What could be improved?
- Maybe the `Convert` method from `Bank` should return the `ConversionResult`...
  - What do you think about it?
  - Let's keep it for a later constraint